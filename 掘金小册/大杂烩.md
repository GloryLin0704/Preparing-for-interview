#### typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？

- `typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型

- `typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型

- 对于基本类型来说，想直接通过 `instanceof` 来判断类型是不行的



#### 如何理解原型？如何理解原型链？

- `Object` 是所有对象的爸爸，所有对象都可以通过 `__proto__` 找到它
- `Function` 是所有函数的爸爸，所有函数都可以通过 `__proto__` 找到它
- 函数的 `prototype` 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

- 原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型，但是并不是所有函数都具有这个属性，`Function.prototype.bind()` 就没有这个属性。

 

#### 并发和并行的区别

- 并发是宏观概念，分别有任务A和任务B，在一段时间内 **通过任务间的切换 **完成了这两个任务
- 并行是微观概念，假设CPU中存在两个核心，**同时完成** 任务A和B



#### 什么是回调函数？回调函数有什么缺点？如何解决回调函数问题？

在进行某个操作之后，将其操作结果放在函数中执行；容易写出回调地狱，不利于阅读和维护，嵌套函数一多，就难处理错误；



#### 你理解的 Generator 是什么？

- `Generator` 最大的特点就是可以控制函数的执行。
- 第一次执行 yield 的时候，传参会被忽略，yield 右边的值作为调用时的返回值
- yield 如果不传参，在函数执行时的返回值是 undefined

> 控制函数的执行

```js
function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```



#### Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？

特点：

- 能够解决回调地狱的问题，优化异步的写法
- 有三种状态，一旦从等待状态变为其他状态，就不会再改变

------

- `Promise` 实现了链式调用，也就是说每次调用 `then` 之后返回的都是一个 `Promise`，并且是一个全新的 `Promise`，原因也是因为状态不可变

------

- 当我们在构造 `Promise` 的时候，构造函数内部的代码是立即执行的



忧缺点：

- 很好地解决了回调地狱的问题
- Promise 一旦开始，就无法取消
- 错误需要通过回调函数捕获？？？



#### async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？

- 一个函数如果加上 `async` ，那么该函数就会返回一个 `Promise`
- 在`async`中，如果`return`的表达式不返回 `Promise` 的话，就将函数返回值使用 `Promise.resolve()` 包裹，和 `then` 中处理返回值一样，并且 `await` 只能配套 `async` 使用



缺点：

- 因为 `await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低（ Promise.all( )  ）



原理：

- `await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 `Promise` 的语法糖，且内部实现了自动执行 `generator`



#### setTimeout、setInterval、requestAnimationFrame 各有什么特点？

- `setTimeout` 延迟多久去执行，但时间不一定精确，受同步代码执行性能的影响

- `setInterval` 每隔一段时间去执行一次回调函数，存在执行累积的问题

- `requestAnimationFrame`

  https://www.cnblogs.com/xiaohuochai/p/5777186.html



#### 进程与线程区别？JS 单线程带来的好处？

- 进程 是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例，多进程挂掉一个进程还可以进行，地址独立。
- 线程 是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量，多线程挂掉一个线程就都挂了，地址共享



#### call apply bind 

- call 和 apply 都是将 this 绑定到传入的上下文中， call 的参数是一个个传，apply 的参数是一个数组，调用即执行函数
- bind 也是将 this 绑定在传入的上下文中，但是调用返回的是绑定了这个上下文的函数，需要再次调用才执行函数

```js
call 和 bind 
// 核心是改变 this，那么就将这个 函数 被传入的 context 调用，就达到了目的
Function.prototype.call = function(context){
    if(typeof this !== 'funciont'){
        throw new TypeError('Error')
    };
    context = context || window;
    // 将调用的函数赋值到 fn 中
    context.fn = this;
    // 取出 call 的参数
    let args = [...arguments].slice(1);
    // 改变 fn 的 this 去调用函数 fn
   	let result = context.fn(args);
    delete context.fn
	return result;  
}
```



#### new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？

- 新生成了一个对象
- 链接到原型
- 绑定 this
- 返回新对象



- 因为使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```js
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
```



#### instanceof 的原理

- 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`
- 首先获取类型的原型
- 然后获得对象的原型
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

```js
left = left.__proto__
right = right.prototype
if(left === right) return true;
if(left === null || left === undefined) return false;
left = left.__proto__
```



#### 为什么 0.1 + 0.2 != 0.3

- 因为 0.1 在二进制中是个无限循环的状态，但是 JS 采用的浮点数标准却会裁剪掉我们的数字，就会出现精度丢失的问题。其实很多十进制小数用二进制表示都是无限循环的
- `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
parseFloat((0.1+0.2).toFixed(10));
```



- 二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，



#### V8 下的垃圾回收机制是怎么样的？

- V8 将内存（堆）分为 `新生代` 和 `老生代` 两部分。分代式垃圾回收机制



新生代：

- 新生代中的对象一般存活时间较短，使用 准确式 GC 算法。
- 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。



老生代：

- 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 `标记清除算法` 和 `标记压缩算法`。
- 出现在老生代空间的对象
  - 新生代中的对象已经经历过一次 Scavenge 算法，会将对象从新生代空间移到老生代空间中。
  - To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
- 启动标记清除算法的时机
  - 某一个空间没有分块的时候
  - 空间中被对象超过一定限制
  - 空间不能保证新生代中的对象移动到老生代中
- 遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。



#### JavaScript垃圾回收机制

- **标记清除** 在运行的时候会给存储在内存中的所有变量都加上标记。当变量离开环境时，就标上“离开环境”，可被清除。
- **引用计数** 引用计数的含义是跟踪记录每个值被引用的次数，当值为 0 的时候，代表没有变量在访问它了，可以被清除掉了。



#### JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？

1. 对于原始类型来说，你可以指出 `null` 和 `number` 存在的一些问题。对于对象类型来说，你可以从垃圾回收的角度去切入，也可以说一下对象类型存在深浅拷贝的问题。
2. 对于判断类型来说，你可以去对比一下 `typeof` 和 `instanceof` 之间的区别，也可以指出 `instanceof` 判断类型也不是完全准确的。



#### 你理解的原型是什么？

起码说出原型小节中的总结内容，然后还可以指出一些小点，比如并不是所有函数都有 `prototype` 属性，然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 `class` 实现继承。



#### bind、call 和 apply 各自有什么区别？

首先肯定是说出三者的不同，如果自己实现过其中的函数，可以尝试说出自己的思路。然后可以聊一聊 `this` 的内容，有几种规则判断 `this` 到底是什么，`this` 规则会涉及到 `new`，那么最后可以说下自己对于 `new` 的理解。



已实现 call apply 




