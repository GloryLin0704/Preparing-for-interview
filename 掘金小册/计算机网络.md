#### UDP 与 TCP 的区别是什么？
- 面向无连接
  - UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方
  - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
  - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
- 不可靠性
  - UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，收到什么数据就传递什么数据。
  - UDP 协议也没有任何控制流量的算法，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。
  - 弊端是在网络条件不好的情况下可能会导致丢包
  - 优点是实时性很强，直播

- 传输方式
  - UDP 提供了单播，多播，广播的功能



#### 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接

- 确认双方都可以正常发送和接收
- 防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误

- 在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次
  - 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文
  - 当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文
  - 当FIN=1，该字段为一表示此报文段是一个释放连接的请求报文。



#### 四次挥手

- TCP 是全双工的，双方都可以发送和接收，所以断开TCP的时候要双方都断开发送和接收
- 第一次，A  =>  B，A 告诉 B，我要发送的东西发完了（A 停止发送）
- 第二次，B  =>  A，B 告诉 A，好的，我不接收你的东西了（B 停止接收）
- 第三次，B  =>  A，B 告诉 A，我要发送的东西也发完了（B 停止发送）
- 第四次，A  =>  B，A 告诉 B，好的，我不接收你的东西了（A 停止接收）



在第四次握手的时候， A 会等待一个最大段生存期才关闭连接状态，为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态



#### ARQ 协议

- ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议。

**停止等待 ARQ**

- 只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。

**连续ARQ**

- 发送端拥有一个**发送窗口**，可以在没有收到应答的情况下持续发送窗口内的数据

- 接收端可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。

- 累计确认也有一个弊端，当数据丢失时，可能会造成发送端重复发送数据的情况



#### 滑动窗口（流量控制）

- 分别为发送端窗口和接收端窗口，接收端窗口决定发送端窗口，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小
- 发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据
- 滑动窗口是一个很重要的概念，它帮助 TCP 实现了**流量控制**的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况。

- 当接收端返回的时零窗口，发送端停止发送数据，设置定时器，让对端告知窗口大小，经过一定次数后，可能会中断 TCP 链接



#### 拥塞处理

- 作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。
- 拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。



**慢开始**

- 在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。
- 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
- 每过一个 RTT 就将窗口大小乘二。RTT表示发送端发送数据到接收到对端数据所需的往返时间。

- 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法



**拥塞避免**

- 每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值
- 传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤
  - 将阈值设为当前拥塞窗口的一半
  - 将拥塞窗口设为 1 MSS
  - 启动拥塞避免算法



**快速重传 && 快速恢复**

- 不是很懂。。。。。



#### TCP



- 建立连接需要三次握手，断开连接需要四次握手
- 滑动窗口解决了数据的丢包、顺序不对和流量控制问题
- 拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据



#### TLS 的三次握手

- TLS 的加密方式分为 对称加密、非对称加密
- 首先是客户端生成一个随机值，并将需要使用的协议和加密方式一起发给服务端
- 服务端收到后，使用对应的协议和加密方式响应，并生成一个随机数和自己的证书一起发回去
- 客户端先验证证书是否有效，如果有效，用证书上的公钥加密一个随机值，和自己的证书再发回去
- 此时双方都有了三个随机值，这时候用这三个随机值，通过第一次发送时的加密方式，生成密钥
- 往后的信息，就用密钥来加密解密。
- 至此，TLS的三次握手结束。在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。



### http/https 协议

- 1.0 协议缺陷:
  - 无法复用链接，完成即断开，**重新慢启动 和 TCP 3次握手**
  - head of line blocking: **队头阻塞**，导致请求之间互相影响，chrome 下好像是允许6个同时进行
- 1.1 改进:
  - **长连接**(默认 keep-alive)，复用链接
  - host 字段指定对应的虚拟站点
  - 新增功能:
    - 断点续传
    - 身份认证
    - 状态管理
    - cache 缓存
      - Cache-Control
      - Expires
      - Last-Modified ( if-Modified-Since)
      - Etag( if-None-Match )
- 2.0:
  - 多路复用，解决队头阻塞问题
    - 两个非常重要的概念，分别是帧（frame）和流（stream）
    - 就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求
  - 二进制分帧层: 应用层和传输层之间，以前是文本，现在是二进制
  - 首部压缩，压缩 header 的内容，以前也是文本，两端建立索引表，记录出现过的 header，往后的传输只需传键名就可以找到键值
  - 服务端推送
    - 在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源
    - 某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间
- 2.0 的缺点
  -  HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。
  - 因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。
- 3.0
  - 基于 UDP 协议的 QUIC 协议
  - 原生实现多路复用，解决 TCP 只有一个连接，丢包时候出现的问题
  -  QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上
  - 纠错机制，有个校验包，丢失一个非校验包是可推出，丢多个就要重传

- https: 较为安全的网络传输协议
  - 证书(公钥)
  - SSL 加密
  - 端口 443



#### WebSocket 的握手（两次）

- 待 TCP 握手完成之后，浏览器通过 HTTP 协议传输 WebSocket 的版本号，主机地址之类的信息给服务端
- 服务器接收到握手请求之后，如何数据和格式正确，则接收本次请求，给予响应，也是 HTTP
- 浏览器收到相应之后，如何内容和格式正确，则建立完成





























