#### call apply bind 

- call 和 apply 都是将 this 绑定到传入的上下文中， call 的参数是一个个传，apply 的参数是一个数组，调用即执行函数
- bind 也是将 this 绑定在传入的上下文中，但是调用返回的是绑定了这个上下文的函数，需要再次调用才执行函数

```js
call 和 bind 
// 核心是改变 this，那么就将这个 函数 被传入的 context 调用，就达到了目的
Function.prototype.call = function(context){
    if(typeof this !== 'funciont'){
        throw new TypeError('Error')
    };
    context = context || window;
    // 将调用的函数赋值到 fn 中
    context.fn = this;
    // 取出 call 的参数
    let args = [...arguments].slice(1);
    // 改变 fn 的 this 去调用函数 fn
   	let result = context.fn(args);
    delete context.fn
	return result;  
}
```



#### new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？

- 新生成了一个对象
- 链接到原型
- 绑定 this
- 返回新对象



- 因为使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```js
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
```



#### instanceof 的原理

- 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`

- 首先获取类型的原型
- 然后获得对象的原型
- 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 `null`，因为原型链最终为 `null`

```js
left = left.__proto__
right = right.prototype
if(left === right) return true;
if(left === null || left === undefined) return false;
left = left.__proto__
```



#### 为什么 0.1 + 0.2 != 0.3

- 因为 0.1 在二进制中是个无限循环的状态，但是 JS 采用的浮点数标准却会裁剪掉我们的数字，就会出现精度丢失的问题。其实很多十进制小数用二进制表示都是无限循环的

- `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
parseFloat((0.1+0.2).toFixed(10));
```



- 二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，



#### V8 下的垃圾回收机制是怎么样的？



- V8 将内存（堆）分为 `新生代` 和 `老生代` 两部分。分代式垃圾回收机制



新生代：

- 新生代中的对象一般存活时间较短，使用 准确式 GC 算法。

- 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。



老生代：

- 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是 `标记清除算法` 和 `标记压缩算法`。

- 出现在老生代空间的对象
  - 新生代中的对象已经经历过一次 Scavenge 算法，会将对象从新生代空间移到老生代空间中。
  - To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
- 启动标记清除算法的时机
  - 某一个空间没有分块的时候
  - 空间中被对象超过一定限制
  - 空间不能保证新生代中的对象移动到老生代中

- 遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。



#### JavaScript垃圾回收机制



- **标记清除** 在运行的时候会给存储在内存中的所有变量都加上标记。当变量离开环境时，就标上“离开环境”，可被清除。
- **引用计数** 引用计数的含义是跟踪记录每个值被引用的次数，当值为 0 的时候，代表没有变量在访问它了，可以被清除掉了。











