> 浏览器缓存方案

浏览器有两种缓存方案，一个是强缓存，一个是协商缓存。

若本地有缓存并且没过期，就使用；没有的话就带上 ETag 和 Last-Modified 访问服务器，若还在有效期，返回304使用缓存，若没有就请求真正的数据。

> 浏览器强缓存

第一种是，浏览器在第一次请求资源的时候，服务端响应头里可以设置 `expires` 字段，这个字段表示该资源的缓存过期时间，第二次请求的时候，如果还在缓存时间里，则直接使用缓存，否则重新加载资源，但是这个 `expires` 字段有个缺陷，就是它必须服务端和客户端的时间严格同步才能生效；

第二种是，浏览器第一次请求资源时，服务端设置响应头 `cache-control: max-age`，告诉浏览器，这个资源什么时候过期，等第二次请求资源的时候，判断是否超出过期时间，如果没超出，直接使用缓存。

如果两者同时存在，使用 `cache-control`

> `cache-control` 的其他值

`public` 客户端和服务端都可以缓存;

`private` 只能客户端缓存;

`no-store` 不使用缓存;

`no-cache` 使用协商缓存;

> 协商缓存

第一种是，`Last-Modified`，就是第一次请求资源的时候，服务端在响应头里设置字段，表示该资源的最后修改时间，浏览器第二次请求该资源的时候，会在请求头里面加上一个字段，`If-Modified-Since`，值为第一次请求的时候，服务端返回的 `Last-Modified` 的值，服务端会判断资源当时的最后更改时间与请求头里面的 `Last-Modified-Since` 字段是否相同，如果相同，则告诉客户端使用缓存，否则重新下载资源。

第二种是，使用 `ETag` 字段，原理和 `Last-Modified` 类似，就是第一次请求的时候，服务端会根据资源的内容或者最后修改时间生成一个标识，然后在响应头里面设置 `ETag` 返回会客户端，客户端第二次请求的时候会在请求头里面带上这个 `ETag`，也就是在请求头里面加上 `If-None-Match` 字段，服务端接收到了 `ETag` 之后判断是否与原来第一次的标识相同，如果相同，则告诉客户端使用缓存。

二者的区别，`Last-Modified` 的主要缺点是只能精确到秒的级别，也就是说，一旦在一秒内出现在了多次修改，那么 `Last-Modified / If-Modified-Since` 就无法发挥作用；而 `ETag` 没有使用时间作为标准，而是使用一个特征串，不存在上述 `Last-Modified` 的缺陷
